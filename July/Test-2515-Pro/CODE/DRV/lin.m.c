#include "common.h"



/* -------------------------------------------------- */
// ● LIN 主机模式
/* -------------------------------------------------- */



/* -------------------------------------------------- */
// ● 全局变量
// ● 以下信号数据基于道奇汽车的ECU
/* -------------------------------------------------- */

/**
 * LIN 基础变量
 */
u32 GV_LinMasterBaudRate     = 19200;  // 波特率，常用波特率：9600、19200
u32 GV_LinMasterSendInterval = 50;    // 信号下发到设备的间隔时间（毫秒）


/**
 * LIN 调试相关变量
 */
short GV_LinMasterDebugSendOutUart1        = 0;  // Debug 发送时数据输出到 UART1
short GV_LinMasterDebugSendOutPrintf       = 0;  // Debug 发送时数据输出到 printf（注意：该系统中可能重载 printf 函数输出到 UART1）
short GV_LinMasterDebugReceiveOutUart1     = 0;  // Debug 接收时数据输出到 UART1
short GV_LinMasterDebugReceiveOutPrintf    = 0;  // Debug 接收时数据输出到 printf（注意：该系统中可能重载 printf 函数输出到 UART1）
short GV_LinMasterDebugReceiveChkOutUart1  = 0;  // Debug 反馈信号检测时输出到 UART1
short GV_LinMasterDebugReceiveChkOutPrintf = 0;  // Debug 反馈信号检测时输出到 printf（注意：该系统中可能重载 printf 函数输出到 UART1）


/**
 * LIN 主信号相关变量
 * 主信号是指会收到从机反馈的信号
 */
u8 GV_LinMasterPrimarySignal[]            = {0x42, 0x00, 0x00, 0x00, 0x02, 0xBB};  // 【按需设置】汽车 ON 档默认的主信号（ID，DATA，CheckNum）
                                                                                   // 　　　　　　该变量包含了主机发送的ID，从机默认响应的数据 和 校验码
                                                                                   // 　　　　　　系统自动根据该变量提取并发送ID，以及匹对从机反馈的信号是否准确等功能
                                                                                   // 【自产件】KD-281-1 ：{0x42, 0x40, 0x00, 0x20, 0x04, 0x59};  // 线路板上未放置铜片，锁窗键处于触发状态
                                                                                   // 【原厂件】KD-281-2 ：{0x42, 0x00, 0x00, 0x00, 0x02, 0xBB};
                                                                                   // 【自产件】KD-281-3 ：{0x42, 0x00, 0x00, 0x20, 0x04, 0x99};  // 线路板上未放置铜片，锁窗键处于触发状态
                                                                                   // 【原厂件】KD-281-27：{0x42, 0x00, 0x00, 0x00, 0xF2, 0xCA};

u8 GV_LinMasterPrimaryReceive[]           = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};  // 【系统使用】主信号发送后收到的反馈信号容器，包含 ID，DATA，CheckNum；数组长度需要和 GV_LinMasterPrimarySignal 一样
u8 GV_LinMasterPrimaryReceiveCnt          = 0;                                     // 【系统使用】用于 GV_LinMasterPrimaryReceive 数组变量保存数据的个数
u8 GV_LinMasterPrimaryReceiveWait         = 0;                                     // 【系统使用】主信号等待反馈的标志，系统自动设置该标志后中断才正式将反馈信号记录到 GV_LinMasterPrimaryReceive
u8 GV_LinMasterPrimaryReceiveChks[]       = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};  // 【系统使用】反馈信号检测的临时储存容器，包含 ID，DATA，CheckNum；数组长度需要和 GV_LinMasterPrimarySignal 一样
u8 GV_LinMasterPrimaryReceivePrev[]       = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};  // 【系统使用】上一个信号临时储存容器，包含 ID，DATA，CheckNum；数组长度需要和 GV_LinMasterPrimarySignal 一样

u8 GV_LinMasterPrimaryReceiveToUsbMode    = LIN_TXUSB_MODE_DOWNUPONE;              // 【按需设置】主信号发送后收到的反馈信号输出模式：LIN_TXUSB_MODE_DOWNONE（从机按下发送一次）, LIN_TXUSB_MODE_DOWNUPONE（从机按下和松开各发送一次）
u8 GV_LinMasterPrimaryReceiveToUsbDnHead  = 0xAE;                                  // 【按需设置】从机按下发送一次信号的数据头
u8 GV_LinMasterPrimaryReceiveToUsbDnFoot  = 0xAF;                                  // 【按需设置】从机按下发送一次信号的数据尾
u8 GV_LinMasterPrimaryReceiveToUsbUpHead  = 0xBE;                                  // 【按需设置】从机松开发送一次信号的数据头
u8 GV_LinMasterPrimaryReceiveToUsbUpFoot  = 0xBF;                                  // 【按需设置】从机松开发送一次信号的数据尾


/**
 * LIN 辅信号相关变量
 * 辅信号仅仅用于主机通知从机
 */
u8 GV_LinMasterAuxSignal[]      = {0x80, 0x00, 0xF8};  // 汽车 ON 档默认下发的辅信号（ID 和 DATA，不含 CheckNum），一般用于汽车 ECU 通知开关背光灯亮或左右使能灯亮等情况
u8 GV_LinMasterAuxSignalBox[]   = {0x00, 0x00, 0x00};  // 【系统使用】下发的辅信号容器，数组长度和 GV_LinMasterAuxSignal 一致；主要用于构建并存放即将发送辅信号


/**
 * LIN 查找信号相关变量
 */
u8 GV_LinMasterFindReceiveCnt   = 0;  // 【系统使用】用于 GV_LinMasterFindReceive 数组变量保存数据的个数
u8 GV_LinMasterFindReceiveWait  = 0;  // 【系统使用】查信号等待反馈的标志，系统自动设置该标志后中断才正式将反馈信号记录到 GV_LinMasterFindReceive
u8 GV_LinMasterFindReceive[20];       // 【系统使用】查信号发送后收到的反馈信号容器，包含 ID，DATA，CheckNum



/* -------------------------------------------------- */
// ● 函数主体（主信号）
/* -------------------------------------------------- */

/**
 * 【主信号】发送主信号给从机
 * 主信号是指会收到从机反馈的信号
 *
 * 发送主信号 ID 后，从机会反馈信号，在 STM8 的 "INTERRUPT_HANDLER(UART3_RX_IRQHandler,21)" 中断里
 * 调用了 UART3_InterruptHandlerRX()->LIN_MASTER_InterruptHandlerRxPrimaryReceive() 函数并保存反馈的数据到全局变量 GV_LinMasterPrimaryReceive
 */
void LIN_MASTER_SendPrimarySignal()
{
    // 准备数据接收
    GV_LinMasterPrimaryReceiveCnt  = 0;
    GV_LinMasterPrimaryReceiveWait = 1;
    
    // 发送间隔段，同步段，ID
    UART3_SendBreak();
    UART3_SendByte(0x55);
    UART3_SendByte(GV_LinMasterPrimarySignal[0]);
    
    // 时间间隔
    // 等待接收反馈信号
    delay_ms(GV_LinMasterSendInterval);
}


/**
 * 【主信号】发送接收的信号到 USB
 * 支持以下两种模式：从机按下发一次信号；从机按下和松开发一次。具体参见变量：GV_LinMasterPrimaryReceiveToUsbMode
 */
void LIN_MASTER_SendPrimaryReceiveToUsb()
{
    // 初始化
    u8 i, match;
    u8 mode = GV_LinMasterPrimaryReceiveToUsbMode;
    u8 length = ARR_LENGTH(GV_LinMasterPrimaryReceive);

    // 当前接收到的反馈信号 和 默认信号 比较
    match = 1; for( i = 0; i < length; i++ ) match &= GV_LinMasterPrimarySignal[i] == GV_LinMasterPrimaryReceive[i];

    // 当前接收到的反馈信号 和 默认信号 相同，说明此时从机的没有按键按下或其他默认情况
    if( match == 1 ){
        // 按键没有按下，那么直接退出
        // 原理：上一个信号变量中数据全部是 0，那么说明线路板上一个状态也是默认状态
        match = 1; for( i = 0; i < length; i++ ) match &= GV_LinMasterPrimaryReceivePrev[i] == 0x00;
        if( match == 1 ) return;
        
        // 上一个信号变量中数据非全 0，那么说明上一个状态按键按下，那么此时的程序逻辑就是由按键松开触发
        if( mode == LIN_TXUSB_MODE_DOWNUPONE ){
            UART1_SendByte(GV_LinMasterPrimaryReceiveToUsbUpHead); UART1_SendByte(length);
            for( i = 0; i < length; i++ ) UART1_SendByte(GV_LinMasterPrimaryReceivePrev[i]);
            UART1_SendByte(GV_LinMasterPrimaryReceiveToUsbUpHead);
        }

        // 重置上一个信号
        for( i = 0; i < length; i++ ) GV_LinMasterPrimaryReceivePrev[i] = 0x00;

        // 返回
        return;
    }
    
    // 当前接收到的反馈信号 和 默认信号 不相同，说明此时从机的按键按下了
    else{
        // 当前接收到的反馈信号和上一个信号相同则不发送反馈信号
        match = 1; for( i = 0; i < length; i++ ) match &= GV_LinMasterPrimaryReceivePrev[i] == GV_LinMasterPrimaryReceive[i];
        if( match == 1 ) return;
    }
    
    // 发送开头数据
    UART1_SendByte(GV_LinMasterPrimaryReceiveToUsbDnHead);
    UART1_SendByte(length);
    
    // 发送反馈信号到 USB
    for( i = 0; i < length; i++ ) UART1_SendByte(GV_LinMasterPrimaryReceive[i]);

    // 保存当前数据到上一个信号的变量中
    for( i = 0; i < length; i++ ) GV_LinMasterPrimaryReceivePrev[i] = GV_LinMasterPrimaryReceive[i];

    // 发送收尾数据
    UART1_SendByte(GV_LinMasterPrimaryReceiveToUsbDnFoot);
}


/**
 * 【主信号】重置接收反馈信号
 */
void LIN_MASTER_PrimaryReceiveReset()
{
    GV_LinMasterPrimaryReceiveCnt  = 0;
    GV_LinMasterPrimaryReceiveWait = 0;
}


/**
 * 【主信号】反馈信号包含检测
 * 该函数根据全局变量 GV_LinMasterPrimaryReceive 值为基础
 * 该函数采用位码标记法，例如：1H40(表示检查 LIN 的数据段第1个数据字节的高位4是否等于0)
 * 　　　　　　　　　　　　　　2L11(表示检查 LIN 的数据段第2个数据字节的低位1是否等于1)
 *
 * @param dataNum           数据编号：从 1 开始
 * @param dataHightLow      数据高低位：H、L
 * @param data8421Bit       数据位，以 8421 为基准
 * @param data8421BitValue  数据位值：0、1
 *
 * @return 0 表示不包含，1 表示包含
 */
short LIN_MASTER_PrimaryReceiveContain( short dataNum, char dataHighLow, short data8421Bit, short data8421BitValue )
{
    // 重构数据位
    if( dataHighLow == 'h' ) data8421Bit = data8421Bit << 4;
    if( dataHighLow == 'H' ) data8421Bit = data8421Bit << 4;

    if( data8421BitValue == 0 && (GV_LinMasterPrimaryReceive[dataNum]&data8421Bit) == 0 ) return 1;
    if( data8421BitValue == 1 && (GV_LinMasterPrimaryReceive[dataNum]&data8421Bit) == data8421Bit ) return 1;
    
    return 0;
}



/* -------------------------------------------------- */
// ● 函数主体（主信号中断）
/* -------------------------------------------------- */

/**
 * 【主信号】接收反馈的信号
 * 该函数在 UART 的中断中被调用，它能自动根据相关的配置决定是否记录数据
 *
 * @param byte  8位字节
 */
void LIN_MASTER_InterruptHandlerRxPrimaryReceive( u8 byte )
{
    // 无效参数
    if( GV_LinMasterPrimaryReceiveWait == 0 ) return;
    if( GV_LinMasterPrimaryReceiveCnt >= ARR_LENGTH(GV_LinMasterPrimaryReceive) ) return;

    // 接收间隔段和同步段并过滤
    if( GV_LinMasterPrimaryReceiveWait == 1 && byte == 0x00 ){ GV_LinMasterPrimaryReceiveWait = 2; return; }
    if( GV_LinMasterPrimaryReceiveWait == 2 && byte == 0x55 ){ GV_LinMasterPrimaryReceiveWait = 3; return; }
    if( GV_LinMasterPrimaryReceiveWait != 3 ) return;
    
    //【DEBUG】 输出接收到的反馈信号
    if( GV_LinMasterDebugReceiveOutUart1  == 1 ) UART1_SendByte(byte);
    if( GV_LinMasterDebugReceiveOutPrintf == 1 ) printf("%02X ", byte);

    // 数据赋值
    GV_LinMasterPrimaryReceive[GV_LinMasterPrimaryReceiveCnt++] = byte;
}



/* -------------------------------------------------- */
// ● 函数主体（辅信号）
/* -------------------------------------------------- */

/**
 * 【辅信号】初始化下发的辅信号
 * 该函数直接初始化全局变量 GV_LinMasterAuxSignalBox
 */
void LIN_MASTER_InitAuxSignal()
{
    for( int i=0; i < ARR_LENGTH(GV_LinMasterAuxSignal); i++ ) GV_LinMasterAuxSignalBox[i] = GV_LinMasterAuxSignal[i];
}


/**
 * 【辅信号】设置下发的辅信号
 * 该函数直接设置全局变量 GV_LinMasterAuxSignalBox
 * 该函数采用位码标记法，例如：1H40(表示将LIN的数据段第1个数据字节的高位4设置为0)
 * 　　　　　　　　　　　　　　2L11(表示将LIN的数据段第2个数据字节的低位1设置为1)
 *
 * @param dataNum           数据编号：从 1 开始
 * @param dataHightLow      数据高低位：H、L
 * @param data8421Bit       数据位：8、4、2、1
 * @param data8421BitValue  数据位值：0、1
 */
void LIN_MASTER_SetAuxSignal( short dataNum, char dataHighLow, short data8421Bit, short data8421BitValue )
{
    // 重构数据位
    if( dataHighLow == 'h' ) data8421Bit = data8421Bit << 4;
    if( dataHighLow == 'H' ) data8421Bit = data8421Bit << 4;

    // 设置下发的辅信号
    if( data8421BitValue == 1 ) GV_LinMasterAuxSignalBox[dataNum] |= data8421Bit;
    if( data8421BitValue == 0 ) GV_LinMasterAuxSignalBox[dataNum] &= data8421Bit^0xFF;
}


/**
 * 【辅信号】发送下发的辅信号
 * 该函数直接发送全局变量 GV_LinMasterAuxSignalBox 里的数据
 */
void LIN_MASTER_SendAuxSignal()
{
    // 初始化
    u8 length = ARR_LENGTH(GV_LinMasterAuxSignal);

    // 发送 LIN 标志
    UART3_SendBreak();
    UART3_SendByte(0x55);

    // 发送下发的辅信号
    for( int i = 0; i < length; i++ ) UART3_SendByte(GV_LinMasterAuxSignalBox[i]);
    UART3_SendByte(LIN_CalcChecknum(GV_LinMasterAuxSignalBox,length,0));

    // 时间间隔
    delay_ms(GV_LinMasterSendInterval);
    
    //【DEBUG】 通过 UART1 串口输出下发的辅信号
    if( GV_LinMasterDebugSendOutUart1 == 1 ){
        for( int i = 0; i < length; i++ ) UART1_SendByte(GV_LinMasterAuxSignalBox[i]);
        UART1_SendByte(LIN_CalcChecknum(GV_LinMasterAuxSignalBox,length,0));
    }
    
    //【DEBUG】 通过 Printf 串口输出下发的辅信号
    if( GV_LinMasterDebugSendOutPrintf == 1 ){
        for( int i = 0; i < ARR_LENGTH(GV_LinMasterAuxSignal); i++ ) printf("%02X ", GV_LinMasterAuxSignalBox[i]);
        printf("%02X\n", LIN_CalcChecknum(GV_LinMasterAuxSignalBox,length,0));
    }
}


/**
 * 【辅信号】设置下发的辅信号
 * 该函数直接设置全局变量 GV_LinMasterAuxSignalBox
 * 直接将数据字节集赋值给 GV_LinMasterAuxSignalBox，但赋值前会检查 ID 是否一致，同时过滤 bytes 中的 Checknum
 *
 * @param datBytes   数据字节集
 * @param datLength  数据字节长度
 */
void LIN_MASTER_SetAuxSignalBytes( u8 datBytes[], u8 datLength )
{
    // 初始化
    u8 i;
    u8 length = ARR_LENGTH(GV_LinMasterAuxSignal);

    // 无效 ID
    if( datBytes[0] != GV_LinMasterAuxSignal[0] ) return;

    // 赋值
    length = length > datLength ? datLength : length;
    for( i = 0; i < length; i++ ) GV_LinMasterAuxSignalBox[i] = datBytes[i];
}


/**
 * 【辅信号】设置下发的辅信号
 * 预设各个功能对应的数据信号
 */
void LIN_MASTER_SetAuxSignalBLedOn(){ LIN_MASTER_SetAuxSignal(1, 'H', 8, 1); }  // 辅信号：背光灯亮
void LIN_MASTER_SetAuxSignalLLedOn(){ LIN_MASTER_SetAuxSignal(1, 'L', 4, 1); }  // 辅信号：左使能灯亮
void LIN_MASTER_SetAuxSignalRLedOn(){ LIN_MASTER_SetAuxSignal(1, 'L', 1, 1); }  // 辅信号：右使能灯亮



/* -------------------------------------------------- */
// ● 函数主体（LIN ID 查找）
/* -------------------------------------------------- */

/**
 * 【LIN ID 查找】发送主信号给从机
 * 主信号是指会收到从机反馈的信号
 *
 * @param id  LIN ID 字节
 */
void LIN_MASTER_SendFindSignal( u8 id )
{
    // 准备数据接收
    GV_LinMasterFindReceiveCnt  = 0;
    GV_LinMasterFindReceiveWait = 1;
    
    // 发送间隔段，同步段，ID
    UART3_SendBreak();
    UART3_SendByte(0x55);
    UART3_SendByte(id);

    // 时间间隔
    delay_ms(GV_LinMasterSendInterval);
}


/**
 * 【LIN ID 查找】发送接收的信号到 USB
 */
void LIN_MASTER_SendFindReceiveToUsb()
{
    // 发送反馈信号到 USB
    for( int i = 0; i < GV_LinMasterFindReceiveCnt; i++ ) UART1_SendByte(GV_LinMasterFindReceive[i]);
}


/**
 * 【LIN ID 查找】重置接收反馈信号
 */
void LIN_MASTER_FindReceiveReset()
{
    GV_LinMasterFindReceiveCnt  = 0;
    GV_LinMasterFindReceiveWait = 0;
}



/* -------------------------------------------------- */
// ● 函数主体（LIN ID 查找中断）
/* -------------------------------------------------- */

/**
 * 【LIN ID 查找】接收反馈的信号
 * 该函数在 UART 的中断中被调用，它能自动根据相关的配置决定是否记录数据
 *
 * @param byte  8位字节
 */
void LIN_MASTER_InterruptHandlerRxFindReceive( u8 byte )
{
    // 无效参数
    if( GV_LinMasterFindReceiveWait == 0 ) return;
    if( GV_LinMasterFindReceiveCnt >= ARR_LENGTH(GV_LinMasterFindReceive) ) return;

    // 接收间隔段和同步段并过滤
    if( GV_LinMasterFindReceiveWait == 1 && byte == 0x00 ){ GV_LinMasterFindReceiveWait = 2; return; }
    if( GV_LinMasterFindReceiveWait == 2 && byte == 0x55 ){ GV_LinMasterFindReceiveWait = 3; return; }
    if( GV_LinMasterFindReceiveWait != 3 ) return;

    //【DEBUG】 输出接收到的反馈信号
    if( GV_LinMasterDebugReceiveOutUart1  == 1 ) UART1_SendByte(byte);
    if( GV_LinMasterDebugReceiveOutPrintf == 1 ) printf("%02X ", byte);

    // 数据赋值
    GV_LinMasterFindReceive[GV_LinMasterFindReceiveCnt++] = byte;
}



/* -------------------------------------------------- */
// ● 函数主体（主信号检测匹配相关）
/* -------------------------------------------------- */

/**
 * 初始反馈的信号（检测专用）
 */
void LIN_MASTER_PrimaryReceiveChkInit()
{
    for( int i=0; i < ARR_LENGTH(GV_LinMasterPrimarySignal); i++ ) GV_LinMasterPrimaryReceiveChks[i] = GV_LinMasterPrimarySignal[i];
}


/**
 * 设置反馈的信号（检测专用）
 * 该函数直接设置全局变量 GV_LinMasterPrimaryReceiveChks
 * 该函数采用位码标记法，例如：1H40(表示将 LIN 的数据段第1个数据字节的高位4设置为0)
 * 　　　　　　　　　　　　　　2L11(表示将 LIN 的数据段第2个数据字节的低位1设置为1)
 *
 * @param dataNum           数据编号：从 1 开始
 * @param dataHightLow      数据高低位：H、L
 * @param data8421Bit       数据位，以 8421 为基准
 * @param data8421BitValue  数据位值：0、1
 */
void LIN_MASTER_PrimaryReceiveChkSet( short dataNum, char dataHighLow, short data8421Bit, short data8421BitValue )
{
    // 重构数据位
    if( dataHighLow == 'h' ) data8421Bit = data8421Bit << 4;
    if( dataHighLow == 'H' ) data8421Bit = data8421Bit << 4;

    // 设置反馈的信号（检测专用）
    if( data8421BitValue == 1 ) GV_LinMasterPrimaryReceiveChks[dataNum] |= data8421Bit;
    if( data8421BitValue == 0 ) GV_LinMasterPrimaryReceiveChks[dataNum] &= data8421Bit^0xFF;
}


// 后视镜向上
short LIN_MASTER_PrimaryReceiveChkHasMirrUp()     { return LIN_MASTER_PrimaryReceiveContain(3,'L',1,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }  
void  LIN_MASTER_PrimaryReceiveChkSetMirrUp()     {         LIN_MASTER_PrimaryReceiveChkSet(3,'L',1,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }
 
// 后视镜向左
short LIN_MASTER_PrimaryReceiveChkHasMirrLeft()   { return LIN_MASTER_PrimaryReceiveContain(3,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }  
void  LIN_MASTER_PrimaryReceiveChkSetMirrLeft()   {         LIN_MASTER_PrimaryReceiveChkSet(3,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 后视镜向下
short LIN_MASTER_PrimaryReceiveChkHasMirrDown()   { return LIN_MASTER_PrimaryReceiveContain(3,'L',2,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetMirrDown()   {         LIN_MASTER_PrimaryReceiveChkSet(3,'L',2,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 后视镜向右
short LIN_MASTER_PrimaryReceiveChkHasMirrRight()  { return LIN_MASTER_PrimaryReceiveContain(3,'L',8,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetMirrRight()  {         LIN_MASTER_PrimaryReceiveChkSet(3,'L',8,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 后视镜辅助按键（包括方向，收放，左右使能）
short LIN_MASTER_PrimaryReceiveChkHasMirrAssist() { return LIN_MASTER_PrimaryReceiveContain(4,'L',8,1); }
void  LIN_MASTER_PrimaryReceiveChkSetMirrAssist() {         LIN_MASTER_PrimaryReceiveChkSet(4,'L',8,1); }

// 后视镜辅助按键（包括方向，收放，左右使能）
short LIN_MASTER_PrimaryReceiveChkHasMirrAssist2(){ return LIN_MASTER_PrimaryReceiveContain(2,'H',4,1); }
void  LIN_MASTER_PrimaryReceiveChkSetMirrAssist2(){         LIN_MASTER_PrimaryReceiveChkSet(2,'H',4,1); }

// 后视镜收放
short LIN_MASTER_PrimaryReceiveChkHasMirrOC()     { return LIN_MASTER_PrimaryReceiveContain(3,'H',1,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetMirrOC()     {         LIN_MASTER_PrimaryReceiveChkSet(3,'H',1,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 左后视镜使能
short LIN_MASTER_PrimaryReceiveChkHasMirrSWL()    { return LIN_MASTER_PrimaryReceiveContain(2,'H',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetMirrSWL()    {         LIN_MASTER_PrimaryReceiveChkSet(2,'H',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 右后视镜使能
short LIN_MASTER_PrimaryReceiveChkHasMirrSWR()    { return LIN_MASTER_PrimaryReceiveContain(2,'H',8,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetMirrSWR()    {         LIN_MASTER_PrimaryReceiveChkSet(2,'H',8,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 左前升
short LIN_MASTER_PrimaryReceiveChkHasLFUp()       { return LIN_MASTER_PrimaryReceiveContain(1,'L',2,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetLFUp()       {         LIN_MASTER_PrimaryReceiveChkSet(1,'L',2,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 左前升一键
short LIN_MASTER_PrimaryReceiveChkHasLFUpA()      { return LIN_MASTER_PrimaryReceiveContain(1,'L',7,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetLFUpA()      {         LIN_MASTER_PrimaryReceiveChkSet(1,'L',7,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 左前一键升
short LIN_MASTER_PrimaryReceiveChkHasLFUpAuto()   { return LIN_MASTER_PrimaryReceiveContain(1,'L',6,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetLFUpAuto()   {         LIN_MASTER_PrimaryReceiveChkSet(1,'L',6,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 左前降
short LIN_MASTER_PrimaryReceiveChkHasLFDown()     { return LIN_MASTER_PrimaryReceiveContain(1,'L',1,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetLFDown()     {         LIN_MASTER_PrimaryReceiveChkSet(1,'L',1,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 左前降一键
short LIN_MASTER_PrimaryReceiveChkHasLFDownA()    { return LIN_MASTER_PrimaryReceiveContain(1,'L',7,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetLFDownA()    {         LIN_MASTER_PrimaryReceiveChkSet(1,'L',7,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 左前一键降
short LIN_MASTER_PrimaryReceiveChkHasLFDownAuto() { return LIN_MASTER_PrimaryReceiveContain(1,'L',5,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }  
void  LIN_MASTER_PrimaryReceiveChkSetLFDownAuto() {         LIN_MASTER_PrimaryReceiveChkSet(1,'L',5,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 右前升
short LIN_MASTER_PrimaryReceiveChkHasRFUp()       { return LIN_MASTER_PrimaryReceiveContain(1,'H',1,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetRFUp()       {         LIN_MASTER_PrimaryReceiveChkSet(1,'H',1,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 右前升一键
short LIN_MASTER_PrimaryReceiveChkHasRFUpA()      { return LIN_MASTER_PrimaryReceiveContain(1,'H',3,1) && LIN_MASTER_PrimaryReceiveContain(1,'L',8,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetRFUpA()      {         LIN_MASTER_PrimaryReceiveChkSet(1,'H',3,1);    LIN_MASTER_PrimaryReceiveChkSet(1,'L',8,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 右前一键升
short LIN_MASTER_PrimaryReceiveChkHasRFUpAuto()   { return LIN_MASTER_PrimaryReceiveContain(1,'H',3,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetRFUpAuto()   {         LIN_MASTER_PrimaryReceiveChkSet(1,'H',3,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 右前降
short LIN_MASTER_PrimaryReceiveChkHasRFDown()     { return LIN_MASTER_PrimaryReceiveContain(1,'L',8,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetRFDown()     {         LIN_MASTER_PrimaryReceiveChkSet(1,'L',8,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 右前降一键
short LIN_MASTER_PrimaryReceiveChkHasRFDownA()    { return LIN_MASTER_PrimaryReceiveContain(1,'H',3,1) && LIN_MASTER_PrimaryReceiveContain(1,'L',8,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetRFDownA()    {         LIN_MASTER_PrimaryReceiveChkSet(1,'H',3,1);    LIN_MASTER_PrimaryReceiveChkSet(1,'L',8,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 右前一键降
short LIN_MASTER_PrimaryReceiveChkHasRFDownAuto() { return LIN_MASTER_PrimaryReceiveContain(1,'H',2,1) && LIN_MASTER_PrimaryReceiveContain(1,'L',8,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',4,1) && LIN_MASTER_PrimaryReceiveContain(4,'L',2,0); }
void  LIN_MASTER_PrimaryReceiveChkSetRFDownAuto() {         LIN_MASTER_PrimaryReceiveChkSet(1,'H',2,1);    LIN_MASTER_PrimaryReceiveChkSet(1,'L',8,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',4,1);    LIN_MASTER_PrimaryReceiveChkSet(4,'L',2,0); }

// 车窗加锁
short LIN_MASTER_PrimaryReceiveChkHasWinLock()    { return LIN_MASTER_PrimaryReceiveContain(3,'H',4,1); }
void  LIN_MASTER_PrimaryReceiveChkSetWinLock()    {         LIN_MASTER_PrimaryReceiveChkSet(3,'H',4,1); }  

// 车窗解锁
short LIN_MASTER_PrimaryReceiveChkHasWinUnLock()  { return LIN_MASTER_PrimaryReceiveContain(3,'H',8,1); }
void  LIN_MASTER_PrimaryReceiveChkSetWinUnLock()  {         LIN_MASTER_PrimaryReceiveChkSet(3,'H',8,1); }  



/* -------------------------------------------------- */
// ● 主逻辑代码
/* -------------------------------------------------- */

/**
 * 主逻辑：查找从机的 ID 标识
 *
 * @param process  显示过程
 */
void LIN_MASTER_MainFindSlaveId( bool process )
{
    // 初始化
    int id;
    int finded = 0;
    
    // LIN ID 遍历
    for( id = 0; id <= 0xFF; id++ ){
        // 发送ID（第一次）
        // 在实际原厂件 KD-281-2 线路板测试中，连续发送2次以上错误ID + 1次正确ID后，返回的数据并完全正确；而发送2次ID就能返回完全正确的数据
        LIN_MASTER_SendFindSignal((u8)id);
        LIN_MASTER_FindReceiveReset();
        
        // 发送ID（第二次）
        LIN_MASTER_SendFindSignal((u8)id);

        // 有反馈信号
        finded = GV_LinMasterFindReceiveCnt > 1 ? 1 : 0;

        // 对反馈信号处理
        if( finded ){
            LIN_MASTER_SendFindReceiveToUsb();  // 发送 LIN 信号到 USB
        }
        else if( process ){
            UART1_SendByte((short)id);
        }

        // 重置接收反馈信号，以便等下次主信号请求
        LIN_MASTER_FindReceiveReset();
    }
}


/**
 * 主逻辑：发送主信号并接收从机的反馈信号，然后输出到 USB
 * 　　　　支持以下两种模式：从机按下发一次信号；从机按下和松开发一次。具体参见变量：GV_LinMasterPrimaryReceiveToUsbMode
 */
void LIN_MASTER_MainPrimaryReceiveToUsb()
{
    // 发送请求主信号
    LIN_MASTER_SendPrimarySignal();

    // 发送接收的信号到 USB
    LIN_MASTER_SendPrimaryReceiveToUsb();  

    // 重置接收反馈信号，以便等下次主信号请求
    LIN_MASTER_PrimaryReceiveReset();
}


/**
 * 主逻辑：发送主信号并接收从机的反馈信号，然后进行检测
 * 该函数一般用于单独的线路板检测
 */
void LIN_MASTER_MainPrimaryReceiveCheck()
{
    // 初始化
    u8 signalMatch;
    u8 signalLength = ARR_LENGTH(GV_LinMasterPrimarySignal);
    u8 signalContain = 0;
    
    // 检测是否与默认信号匹配
    // 反馈的信号与默认信号一样说明了线路板未按下按键
    signalMatch = 1; for( int i = 0; i < signalLength; i++ ) signalMatch &= GV_LinMasterPrimarySignal[i] == GV_LinMasterPrimaryReceive[i];
    
    //【DEBUG】反馈信号检测时输出：接收到的反馈信号
    if( GV_LinMasterDebugReceiveChkOutUart1  == 1 ){ for( u8 i = 0; i < signalLength; i++ ) UART1_SendByte(GV_LinMasterPrimaryReceive[i]); delay_ms(500); }
    if( GV_LinMasterDebugReceiveChkOutPrintf == 1 ){ for( u8 i = 0; i < signalLength; i++ ) printf("==="); printf("\n"); for( u8 i = 0; i < signalLength; i++ ) printf("%02X ", GV_LinMasterPrimaryReceive[i]); printf("\n"); }
    
    // 与默认信号匹配
    //if( signalMatch == 1 ){ LED_Close(2); return; }

    
    // ↓与默认信号不匹配↓
    
    // 初始反馈的信号（检测专用）
    LIN_MASTER_PrimaryReceiveChkInit();
    
    // 检测是否包含正确的按键信号
    // 同时根据按键按下构建理论上的反馈信号（用于检测对比）
    if( LIN_MASTER_PrimaryReceiveChkHasMirrUp()      == 1 ){ LIN_MASTER_PrimaryReceiveChkSetMirrUp();      signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasMirrLeft()    == 1 ){ LIN_MASTER_PrimaryReceiveChkSetMirrLeft();    signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasMirrDown()    == 1 ){ LIN_MASTER_PrimaryReceiveChkSetMirrDown();    signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasMirrRight()   == 1 ){ LIN_MASTER_PrimaryReceiveChkSetMirrRight();   signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasMirrAssist()  == 1 ){ LIN_MASTER_PrimaryReceiveChkSetMirrAssist();  signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasMirrAssist2() == 1 ){ LIN_MASTER_PrimaryReceiveChkSetMirrAssist2(); signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasMirrOC()      == 1 ){ LIN_MASTER_PrimaryReceiveChkSetMirrOC();      signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasMirrSWL()     == 1 ){ LIN_MASTER_PrimaryReceiveChkSetMirrSWL();     signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasMirrSWR()     == 1 ){ LIN_MASTER_PrimaryReceiveChkSetMirrSWR();     signalContain |= 1; }

    if( LIN_MASTER_PrimaryReceiveChkHasLFUp()        == 1 ){ LIN_MASTER_PrimaryReceiveChkSetLFUp();        signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasLFUpA()       == 1 ){ LIN_MASTER_PrimaryReceiveChkSetLFUpA();       signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasLFUpAuto()    == 1 ){ LIN_MASTER_PrimaryReceiveChkSetLFUpAuto();    signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasLFDown()      == 1 ){ LIN_MASTER_PrimaryReceiveChkSetLFDown();      signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasLFDownA()     == 1 ){ LIN_MASTER_PrimaryReceiveChkSetLFDownA();     signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasLFDownAuto()  == 1 ){ LIN_MASTER_PrimaryReceiveChkSetLFDownAuto();  signalContain |= 1; }
    
    if( LIN_MASTER_PrimaryReceiveChkHasRFUp()        == 1 ){ LIN_MASTER_PrimaryReceiveChkSetRFUp();        signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasRFUpA()       == 1 ){ LIN_MASTER_PrimaryReceiveChkSetRFUpA();       signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasRFUpAuto()    == 1 ){ LIN_MASTER_PrimaryReceiveChkSetRFUpAuto();    signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasRFDown()      == 1 ){ LIN_MASTER_PrimaryReceiveChkSetRFDown();      signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasRFDownA()     == 1 ){ LIN_MASTER_PrimaryReceiveChkSetRFDownA();     signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasRFDownAuto()  == 1 ){ LIN_MASTER_PrimaryReceiveChkSetRFDownAuto();  signalContain |= 1; }
    
    if( LIN_MASTER_PrimaryReceiveChkHasWinLock()     == 1 ){ LIN_MASTER_PrimaryReceiveChkSetWinLock();     signalContain |= 1; }
    if( LIN_MASTER_PrimaryReceiveChkHasWinUnLock()   == 1 ){ LIN_MASTER_PrimaryReceiveChkSetWinUnLock();   signalContain |= 1; }

    // 构建反馈信号校验码（检测专用）
    GV_LinMasterPrimaryReceiveChks[signalLength-1] = LIN_CalcChecknum(GV_LinMasterPrimaryReceiveChks, signalLength-1, 0);
      
    //【DEBUG】反馈信号检测时输出：理论上的反馈信号
    if( GV_LinMasterDebugReceiveChkOutUart1  == 1 ){ UART1_SendBytes(GV_LinMasterPrimaryReceiveChks, signalLength); delay_ms(500); }
    if( GV_LinMasterDebugReceiveChkOutPrintf == 1 ){ for( u8 i = 0; i < signalLength; i++ ) printf("%02X ", GV_LinMasterPrimaryReceiveChks[i]); printf("\n"); }
    
    // 比较 接收到的反馈信号 和 理论上的反馈信号 是否一样
    signalMatch = 1; for( int i = 0; i < signalLength; i++ ) signalMatch &= GV_LinMasterPrimaryReceive[i] == GV_LinMasterPrimaryReceiveChks[i];
    
    // 和按照理论值反馈信号不一致，说明接收到的信号有问题
    //if( signalMatch == 0 ){ LED_Open(2); return; }
  
    // 按键按下
    //if( signalContain ){ BUZZER_Open(1); delay_ms(5); BUZZER_Close(1); }
}
